# Chapter 10: Higher-order functions: Lambdas as parameters and return values

- Function types define the inputs and outputs of the lambda, for example; `(Int, String) -> Boolean` or `() -> Unit`

- Here's an example higher-order function that defines a lambda function argument, with a function type;
    ```kotlin
    fun higherOrderFunPrintLambdaOutput(num1: Int, num2: Int, operationToPerformOnTwoNumbers: (Int, Int) -> Int) {
        println("Output: ${operationToPerformOnTwoNumbers(num1, num2)}")
    }

    fun main() {
        higherOrderFunPrintLambdaOutput(2, 3) { x, y -> x + y }
    }
    ```

- And a self-implemented version of the `filter` function (but for `String` only);
    ```kotlin
    fun String.filter(predicate: (Char) -> Boolean) = buildString {
        this@filter.forEach {
            if (predicate(it)) append(it)
        }
    }
    ```

- Function types are normal interfaces under the hood, a lambda is an instance of a class generated by the compiler which implements the interface.
    ```kotlin
    // The interfaces available for use simply correspond to how many arguments the lambda accepts

    // 0 input arguments
    interface Function0<out R> {
        operator fun invoke(): R
    }

    // 1 input argument
    interface Function1<P1, out R> {
        operator fun invoke(p1: P1): R
    }

    interface Function2<P1, P2, out R> {
        operator fun invoke(p1: P1, p2: P2): R
    }
    
    // So an equivalent way of writing the filter function would be;
    fun String.filter(predicate: Function1<Char, Boolean>) = ...
    ```

- Function types can be used as the return type of a function as well;
    ```kotlin
    enum class Delivery { STANDARD, EXPEDITED }

    class Order(val itemCount: Int)

    fun getShippingCostCalculator(delivery: Delivery): (Order) -> Double {
        return when (delivery) {
            is Delivery.STANDARD -> { order -> 1.2 * order.itemCount }
            is Delivery.EXPEDITED -> { order -> 6 + 2.1 * order.itemCount }
        }
    }

    fun main() {
        val calculator = getShippingCostCalculator(Delivery.EXPEDITED)
        println("Shipping costs: ${calculator(Order(3))}")
    }
    ```

- Inlining functions with the `inline` prefix with replace the reference with the actual code snippet at compile time, instead of generating classes and objects during runtime. All lambda parameters are also inlined, unless specifically marked with the `noninline` prefix.

- The `withLock()` extension function can be used to access objects in a threadsafe way
    ```kotlin
    ...
    val l: Lock = ReentrantLock()
    l.withLock {
        // Do some action on the resource
    }
    ...
    ```

- `use()` and `useLines()` can be used to access closeable resources
    ```kotlin
    fun readFirstLineFromFileUse (fileName: String): String {
        BufferedReader(FileReader(filename)).use { br -> return br.readLine() }
    }

    fun readFirstLineFromFileUseLines(filename: String): String {
        Path(fileName).useLines {
            return it.first()
        }
    }
    ```

- Non-local return: Invoking return within a lambda will return from the wider context, as long as the function has been inlined

- Just as with `this@label`, it's possible to `return@label`, as below;
    ```kotlin
    fun lookForAliceNamedLabelReturn(people: List<Person>) {
        people.forEach myLabel@{
            if (it.name != "Alice") return@myLabel  // This return will return to the start of the lambda function, then the forEach lambda will continue to the next iteration
            println("Found Alice!")
        }
    }

    fun lookForAliceLabelReturn(people: List<Person>) {
        people.forEach {
            it (it.name != "Alice") return@forEach  // This return will return to the forEach
            println("Found Alice!")
        }
    }
    ```

- Anonymous functions are another way to inline code snippets, an example is given below;
    ```kotlin
    fun lookForAliceLambdaFun(people: List<Person>) {
        people.forEach {
            if (it.name == "Alice") return  // This return will return out of the enclosing function
        }
    }

    fun lookForAliceAnonFun(people: List<Person>) {
        people.forEach(fun(person) {
            if (person.name == "Alice") return // This return will return out of the anonymous function
        })
    }
    ```

